import{get_request_store as v,with_request_store as x}from"@sveltejs/kit/internal/server";import{parse as B}from"devalue";import{error as q,json as H}from"@sveltejs/kit";import{a as O,f as I,b as J,n as S,e as N,g as A,s as L,c as M}from"./chunks/shared.js";import{ValidationError as V}from"@sveltejs/kit/internal";import{B as z}from"./chunks/vendor.js";import{b as D,c as F,p as T}from"./chunks/environment.js";function k(t,i){if(!i)return e=>{e!==void 0&&q(400,"Bad Request")};if(t==="unchecked")return e=>e;if("~standard"in t)return async e=>{const{event:r,state:s}=v(),u=await t["~standard"].validate(e);return u.issues&&q(400,await s.handleValidationError({issues:u.issues,event:r})),u.value};throw new Error('Invalid validator passed to remote function. Expected "unchecked" or a Standard Schema (https://standardschema.dev)')}async function $(t,i,e,r){await 0;const s=_(t,e);return s[O(i,e.transport)]??=r()}function G(t,i){const e={};for(const r in i)e[r]=i[r].decode;return B(t,e)}async function g(t,i,e,r,s,u){const o={event:{...t,setHeaders:()=>{throw new Error("setHeaders is not allowed in remote functions")},cookies:{...t.cookies,set:(d,c,f)=>{if(!e)throw new Error("Cannot set cookies in `query` or `prerender` functions");if(f.path&&!f.path.startsWith("/"))throw new Error("Cookies set in remote functions must have an absolute path");return t.cookies.set(d,c,f)},delete:(d,c)=>{if(!e)throw new Error("Cannot delete cookies in `query` or `prerender` functions");if(c.path&&!c.path.startsWith("/"))throw new Error("Cookies deleted in remote functions must have an absolute path");return t.cookies.delete(d,c)}}},state:{...i,is_in_remote_function:!0}},a=await x(o,()=>s(r));return x(o,()=>u(a))}function _(t,i=v().state){let e=i.remote_data?.get(t);return e===void 0&&(e={},(i.remote_data??=new Map).set(t,e)),e}function oe(t,i){const e=i??t,r=k(t,i),s={type:"command",id:"",name:""},u=o=>{const{event:a,state:d}=v();if(d.is_endpoint_request){if(!["POST","PUT","PATCH","DELETE"].includes(a.request.method))throw new Error(`Cannot call a command (\`${s.name}(${i?"...":""})\`) from a ${a.request.method} handler`)}else if(!a.isRemoteRequest)throw new Error(`Cannot call a command (\`${s.name}(${i?"...":""})\`) during server-side rendering`);d.refreshes??={};const c=Promise.resolve(g(a,d,!0,o,r,e));return c.updates=()=>{throw new Error(`Cannot call '${s.name}(...).updates(...)' on the server`)},c};return Object.defineProperty(u,"__",{value:s}),Object.defineProperty(u,"pending",{get:()=>0}),u}function ie(t,i){const e=i??t,r=!i||t==="unchecked"?null:t;function s(u){const o={};o.method="POST",Object.defineProperty(o,"enhance",{value:()=>({action:o.action,method:o.method})});const a={type:"submit",onclick:()=>{}};Object.defineProperty(a,"enhance",{value:()=>({type:"submit",formaction:o.buttonProps.formaction,onclick:()=>{}})}),Object.defineProperty(o,"buttonProps",{value:a});const d={type:"form",name:"",id:"",fn:async(c,f,l)=>{const n={};n.submission=!0;const{event:h,state:y}=v(),m=await r?.["~standard"].validate(c);if(f.validate_only)return m?.issues?.map(p=>S(p,!0))??[];if(m?.issues!==void 0)R(n,m.issues,l);else{m!==void 0&&(c=m.value),y.refreshes??={};const p=K();try{n.result=await g(h,y,!0,c,w=>w,w=>i?e(w,p):e())}catch(w){if(w instanceof V)R(n,w.issues,l);else throw w}}return h.isRemoteRequest||(_(d,y)[""]??=n),n}};return Object.defineProperty(o,"__",{value:d}),Object.defineProperty(o,"action",{get:()=>`?/remote=${d.id}`,enumerable:!0}),Object.defineProperty(a,"formaction",{get:()=>`?/remote=${d.id}`,enumerable:!0}),Object.defineProperty(o,"fields",{get(){const c=_(d)?.[""],f=I(c?.issues??[]);return J({},()=>c?.input??{},(l,n)=>{if(c?.submission)return;const h=l.length===0?n:A(c?.input??{},l.map(String),n);(_(d)[""]??={}).input=h},()=>f)}}),Object.defineProperty(o,"result",{get(){try{return _(d)?.[""]?.result}catch{return}}}),Object.defineProperty(o,"pending",{get:()=>0}),Object.defineProperty(a,"pending",{get:()=>0}),Object.defineProperty(o,"preflight",{value:()=>o}),Object.defineProperty(o,"validate",{value:()=>{throw new Error("Cannot call validate() on the server")}}),u==null&&Object.defineProperty(o,"for",{value:c=>{const{state:f}=v(),l=d.id+"|"+JSON.stringify(c);let n=(f.form_instances??=new Map).get(l);return n||(n=s(c),n.__.id=`${d.id}/${encodeURIComponent(JSON.stringify(c))}`,n.__.name=d.name,f.form_instances.set(l,n)),n}}),o}return s()}function R(t,i,e){if(t.issues=i.map(r=>S(r,!0)),e){t.input={};for(let r of e.keys()){if(/^[.\]]?_/.test(r))continue;const s=r.endsWith("[]"),u=e.getAll(r).filter(o=>typeof o=="string");s&&(r=r.slice(0,-2)),N(t.input,r,s?u:u[0])}}}function K(){return new Proxy(e=>{if(typeof e!="string")throw new Error("`invalid` should now be imported from `@sveltejs/kit` to throw validation issues. The second parameter provided to the form function (renamed to `issue`) is still used to construct issues, e.g. `invalid(issue.field('message'))`. For more info see https://github.com/sveltejs/kit/pulls/14768");return t(e)},{get(e,r){return typeof r=="symbol"?e[r]:i(r,[])}});function t(e,r=[]){return{message:e,path:r}}function i(e,r){const s=[...r,e],u=o=>t(o,s);return new Proxy(u,{get(o,a){return typeof a=="symbol"?o[a]:/^\d+$/.test(a)?i(parseInt(a,10),s):i(a,s)}})}}function ae(t,i,e){const r=typeof i=="function"?i:void 0,s=e??(r?void 0:i),u=r??t,o=k(t,r),a={type:"prerender",id:"",name:"",has_arg:!!r,inputs:s?.inputs,dynamic:s?.dynamic},d=c=>{const f=(async()=>{const{event:l,state:n}=v(),h=O(c,n.transport),y=a.id,m=`${D}/${F}/remote/${y}${h?`/${h}`:""}`;if(!n.prerendering&&!z&&!l.isRemoteRequest)try{return await $(a,c,n,async()=>{const b=O(c,n.transport),U=_(a,n),W=U[b]??=fetch(new URL(m,l.url.origin).href).then(async C=>{if(!C.ok)throw new Error("Prerendered response not found");const P=await C.json();return P.type==="error"&&q(P.status,P.error),P.result});return G(await W,n.transport)})}catch{}if(n.prerendering?.remote_responses.has(m))return n.prerendering.remote_responses.get(m);const p=$(a,c,n,()=>g(l,n,!1,c,o,u));n.prerendering&&n.prerendering.remote_responses.set(m,p);const w=await p;if(n.prerendering){const b={type:"result",result:L(w,n.transport)};n.prerendering.dependencies.set(m,{body:JSON.stringify(b),response:H(b)})}return w})();return f.catch(()=>{}),f};return Object.defineProperty(d,"__",{value:a}),d}function Q(t,i){const e=i??t,r=k(t,i),s={type:"query",id:"",name:""},u=o=>{if(T)throw new Error(`Cannot call query '${s.name}' while prerendering, as prerendered pages need static data. Use 'prerender' from $app/server instead`);const{event:a,state:d}=v(),c=()=>g(a,d,!1,o,r,e),f=$(s,o,d,c);return f.catch(()=>{}),f.set=l=>E(j(s,"set",o),l),f.refresh=()=>{const l=j(s,"refresh",o),n=!l.cache[l.cache_key],h=n?f:c();return E(l,h,n)},f.withOverride=()=>{throw new Error(`Cannot call '${s.name}.withOverride()' on the server`)},f};return Object.defineProperty(u,"__",{value:s}),u}function X(t,i){const e=i??t,r=k(t,i),s={type:"query_batch",id:"",name:"",run:a=>{const{event:d,state:c}=v();return g(d,c,!1,a,f=>Promise.all(f.map(r)),e)}};let u={args:[],resolvers:[]};const o=a=>{if(T)throw new Error(`Cannot call query.batch '${s.name}' while prerendering, as prerendered pages need static data. Use 'prerender' from $app/server instead`);const{event:d,state:c}=v(),f=()=>new Promise((n,h)=>{u.args.push(a),u.resolvers.push({resolve:n,reject:h}),!(u.args.length>1)&&setTimeout(async()=>{const y=u;u={args:[],resolvers:[]};try{const m=await g(d,c,!1,y.args,p=>Promise.all(p.map(r)),e);for(let p=0;p<y.resolvers.length;p++)try{y.resolvers[p].resolve(m(y.args[p],p))}catch(w){y.resolvers[p].reject(w)}}catch(m){for(const p of y.resolvers)p.reject(m)}},0)}),l=$(s,a,c,f);return l.catch(()=>{}),l.set=n=>E(j(s,"set",a),n),l.refresh=()=>{const n=j(s,"refresh",a),h=!n.cache[n.cache_key],y=h?l:f();return E(n,y,h)},l.withOverride=()=>{throw new Error(`Cannot call '${s.name}.withOverride()' on the server`)},l};return Object.defineProperty(o,"__",{value:s}),o}Object.defineProperty(Q,"batch",{value:X,enumerable:!0});function j(t,i,e){const{state:r}=v(),{refreshes:s}=r;if(!s){const d=t.type==="query_batch"?`query.batch '${t.name}'`:`query '${t.name}'`;throw new Error(`Cannot call ${i} on ${d} because it is not executed in the context of a command/form remote function`)}const u=_(t,r),o=O(e,r.transport),a=M(t.id,o);return{__:t,state:r,refreshes:s,refreshes_key:a,cache:u,cache_key:o}}function E({__:t,refreshes:i,refreshes_key:e,cache:r,cache_key:s},u,o=!1){const a=Promise.resolve(u);return o||(r[s]=a),t.id&&(i[e]=a),a.then(()=>{})}export{oe as command,ie as form,ae as prerender,Q as query};
